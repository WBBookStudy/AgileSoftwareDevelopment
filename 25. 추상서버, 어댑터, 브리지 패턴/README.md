# 25. 추상서버, 어댑터, 브리지 패턴
단순한 탁상 스탠드 내부에서 돌아갈 소프트웨어를 설계하는 문제가 있었는데, 탁상스탠드에는 전구 하나와 스위치가 있을 뿐이었다.  
지금 켜져있는지 꺼져있는지를 스위치에게 물어볼 수 있었고, 켤지 혹은 끌지를 전구에게 명령할 수 있었다.  
이에 대해 각자 자기가 가장 좋아하는 해결방법을 제시하기로 했는데, 어떤 사람은 그냥 스위치와 전구 객체만 있는 단순한 접근방법을 사용했고, 어떤 사람은 스위치와 전구를 포함하는 램프 객체도 있어야 한다고 생각했다.  
일부는 전기도 객체로 만들고, 전기 코드 객체를 제안하는 사람도 있었다.  
대부분이 말도 안되는 것이긴 해도, 설계 모델 자체는 흥미롭게 연구할 만한 것이었다. 어래 그림을 보자.  
![KakaoTalk_20240728_130349885_01](https://github.com/user-attachments/assets/23e87635-b08f-45ab-8c3d-3e5e12b06ee0)  
Switch 객체는 실제 스위치의 상태를 조사해 상태에 따라 Light 객체에게 turnOn과 turnOff 메시지 중 적절한 것을 보내는데, 이 설계에서 무엇이 맘에 안들까?  
이 설계에서는 의존 관계 역전 원칙(DIP)과 개방 폐쇄 원칙(OCP)이 서로 위반된다는 점이 마음에 안든다.  
Switch에서 Light로 향하는 의존관계가 구체 클래스에 대한 의존 관계이기 때문에 DIP의 위반은 금방 알 수 있다.  
DIP에 따르는 것보다 추상 클래스에 의존하는 편이 낫다. OCP의 위반은 이보다 좀 더 간접적이지만 더 중요한 위반이다.  
이 설계대로면 Switch가 필요할 때마다 Light도 끌고 다녀야 하고, Switch는 Light 외의 객체를 제어하도록 확장하기 힘들다.  

## 추상 서버 패턴
위 그림 처럼 전구 말고 다른 것을 제어하려면 Switch로부터 상속받은 서버클래스를 하나 만들면 된다고 생각할 수 도 있는데, 그걸로 문제가 해결되진 않는다.  
아래 그림처럼 서브클래스인 FanSwitch가 여전히 간접적으로 Light에 대한 의존관계를 갖고 있기 때문이다.  
![KakaoTalk_20240728_130349885](https://github.com/user-attachments/assets/e9248a20-f875-49a4-ad1e-1344d95833f5)  
이 상속관계는 DIP 까지도 위반한다.  
이 문제를 해결하기 위해서 추상서버(Abstract Server)패턴을 사용할 것이다.  
![KakaoTalk_20240728_132343349](https://github.com/user-attachments/assets/7b998d70-93ce-4689-b289-7df1b5ee3ccc)  
Switch와 Light 사이에 인터페이스를 하나 도입함으로써, 이 인터페이스를 구현하는 것이라면 무엇이든 Switch가 제어할 수 있게 만들 수 있다.  
이렇게하면 DIP와 OCP 역시 바로 충족된다.  

### 인터페이스는 누가 소유하는가?
인터페이스의 클라이언트를 위하는 쪽으로 인터페이스 이름을 지었다는 점에 주목하자.  
인터페이스 이름이 ILight가 아니라 Switchable이다.  
인터페이스는 그 인터페이스의 파생클래스나 파생 인터페이스가 아니라 클라이언트에 속한다.  
인터페이스와 그 파생형 사이의 논리적인 구속력보다 클라이언트와 인터페이스 사이의 논리적인 구속력이 더 강하다.  
이러한 논리적 구속력의 강약은 물리적 구속력의 강약과 일치하지 않는데, 연관보다는 상속이 훨씬 강력한 물리적 구속력을 지니기 때문이다.  
과거에는 물리적 구속력이 지배적이라고 생각하곤 했다. 동일한 상속 계층 구조에 속한 클래스들은 동일한 물리적 패키지에 넣도록 권장되기도 했다.  
그때는 상속이 굉장히 물리적 구속력이 강하므로 이렇게 하는 것이 이치에 맞는 것처럼 보였다.  
하지만 최근에는 상속의 물리적 힘에 현혹되기 쉽다는 것과, 상속 계층 구조는 보통 한 패키지에 들어가지 않아야 한다는 것을 배웠다.  
오히려 클라이언트와 그 클라이언트가 제어하는 인터페이스들이 함께 패키지에 들어가곤 했다.  

## 어댑터 패턴
위 추상서버 해결방법의 설계에도 또 다른 문제가 있는데, 단일 책임 원칙(SRP)을 위반할 가능성이 있다는 점이다.  
우리는 변화의 이유가 동일하지 않을 수도 있는 Light와 Switchable 두가지를 묶어놓았다.
Light가 다른것으로 부터 상속을 받을 수 없다면 어떻게 해야할까? Light가 서드파티에서 사온 것이라 소스코드가 없을 수 있다.  
아니면 Switch로 제어하고 싶은 다른 클래스가 있는데 그 클래스가 Switchable로부터 파생 받을수 없다면 어떻게 해야 할까?  
여기서 어댑터가 등장하게 된다.  
![KakaoTalk_20240728_134819752](https://github.com/user-attachments/assets/3189084f-1bfe-4ae9-a0c4-13ff837197a1)  
위 그림을 보면 이 문제를 해결하기 위해 어떻게 어댑터 패턴을 사용하는지 볼 수 있다.  
어댑터가 Switchable로부터 상속을 받은 다음 실제 일은 Light에게 위임한다. 그러면 문제가 깔끔하게 해결된다.  
이제 켜거나 끌 수만 있다면 어떤 객체라도 Switch로 제어할 수 있고, 해야할 일이라곤 적절한 어댑터를 만드는 것 뿐이다.  
물론 제어할 객체가 Switchable과 동일한 turnOn과 turnOff 메소드를 갖고 있을 필요도 없다.  
어댑터가 말 그대로 그 객체의 인터페이스와 Switchable 인터페이스 사이의 **어댑터** 역할을 해주면 된다.  
어댑터는 싸게 먹히지 않는다. 새로 클래스도 작성해야 하고, 어댑터를 인스턴스화 한 다음 어댑터가 중개할 객체와 어댑터를 연결하기도 해야한다.  
그리고ㅓ 어댑터를 호출할 때마다 위임 때문에 필요한 추가적인 시간과 공간이라는 대가를 지불해야 한다. 그래서 매번 어댑터를 쓰고 싶지는 않을 것이다.  
대부분의 경우 추상 서버 패턴을 이용하는 방법으로 충분하다.  

### 클래스 형태의 어댑터 
위 그림에서의 LightAdapter 클래스는 **객체 형태 어댑터(object form adapter)** 라는 이름으로 알려져 있다.  
**클래스 형태 어댑터(class form adapter)** 라는 이름의 접근 방법도 있는데 아래 그림과 같다.  
![KakaoTalk_20240728_135754155](https://github.com/user-attachments/assets/f855d14c-2472-48b0-8faf-825ecca3e2ff)  
이 형태에서 어댑터는 Switchable 인터페이스와 Light 클래스로부터 동시에 상속을 받는다.  
클래스 형태는 객체 형태보다 약간 더 효율적이고 사용하기도 좀 더 쉽지만, 대신 상속에서 강한 결합이 생겨버린다.  

### 모뎀 문제, 어댑터와 LSP
![KakaoTalk_20240728_140155794](https://github.com/user-attachments/assets/2f8db944-2032-4f59-a84d-781f2e0511d3)  
Modem 인터페이스는 HayesModem, USRRoboticsModem, EarniesModem 등 여러 파생형에서 구현된다.  
OCP, LSP, DIP도 충분히 잘 지켜지고 있고, 다루어야 할 새로운 종류의 모뎀이 생겨도 영향을 받지 않는다.  
현재 이 Modem 인터페이스를 만족 스럽게 사용하고 있는 모뎀 클라이언트가 몇백개가 있다고 가정하자. 그리고 이제 고객이 새로운 요구 사항을 건네 주었다.  
전화다이얼을 걸지 않는 종류의 모뎀들이 있는데, 이런 모뎀은 전용 회선의 양쪽에 놓이기 떄문에 전용 모뎀이라고 한다.  
이 전용 모뎀을 사용하기 떄문에 굳이 다이얼을 돌릴 필요가 없는 새로운 애플리케이션 몇개가 있는데, 이 애플리케이션들을 DedUsers 라고 부르자.  
하지만 고객놈은 지금 있는 모뎀 클라이언트들도 모두 전용 회선을 쓸 수 있게 되길 바란다.  
고객은 모뎀 클라이언트 애플리케이션 몇백개를 고치고 싶지는 않으니 이 모뎀 클라이언트들이 그냥 그냥 가짜 전화번호를 돌릴 수 있게 해주었으면 좋겠다고 한다.  
![KakaoTalk_20240728_141029878](https://github.com/user-attachments/assets/592b9806-2c8b-4a38-8e8c-2e60122daca4)  
우리에게 선택의 여지가 있다면 위 그림처럼 설계를 고치면 좋을 것이다.  
다이얼 돌리는 기능과 통신하는 기능을 별개의 인터페이스 2개로 분리하기 위해 ISP를 이용한다.  
이전 모뎀은 이 인터페이스 2개를 모두 구현하고 모뎀 클라이언트들도 인터페이스 2개를 모두 쓰면 된다.  
DedUsers는 단지 Modem 인터페이스만 사용하고 DedicatedModem도 단지 Modem 인터페이스만 구현하면 된다.  
불행하게도 이렇게 할 수 있으려면 모든 모뎀 클라이언트를 수정해야 하는데, 이것을 고객놈이 못하게 막고 있다.  
대신 무엇을 해야할까? 우리가 원하는대로 인터페이스를 분리하지는 못해도, 모든 모뎀 클라이언트가DedicatedModem을 사용할 수 있는 방법은 제공해야 한다.  
다음처럼 Modem으로부터 DedicatedModem을 파생한 다음 dial과 hangup 함수를 아무것도 하지 않는 함수로 구현하는 방법도 가능할 것이다.  
```C++
class DedicatedModem public : Modem {
  public :
    virtual void dial(char phoneNumber[10]) {
    }
    virtual void hangup() {
    }
    virtual void send(char c) {
      ...
    }
    virtual char receive() {
      ...
    }
}
```
하지만 퇴환된 함수는 LSP를 위반하게 될지도 모른다는 신호다.
기반 클래스의 사용자가 dial과 hangup이 모뎀의 상태를 크게 변화시킬 것이라고 여기고 있을지도 모르는데,  
DedicatedModem에서 이렇게 함수를 퇴화시킨다면 이런 예상을 깨버리게 된다.  
모뎀 클라이언트는 아직 다이얼하지 않은 모뎀으로 부터 글자가 들어올 것이라고 예상하지 않는다. 하지만 DedicatedModem은 이런 예상을 깬다.  
전용 모뎀은 dial이 호출되기 이전에도 글자를 보내고, hangup이 호출된 다음에도 그럴것이다.  
DedicatedModem이 일부 모뎀 클라이언트와 충돌할 수도 있다. 그러면 그런 모뎀 클라이언트가 문제라고 주장할지도 모르겠다.  
예상하지 못한 입력에 고장이 난다면 제대로 작성된 소프트웨어가 아니다.  
이 말에 동의하지만, 모뎀 클라이언트의 유지보수를 맡은 담당자에게 우리가 새로운 종류의 모뎀을 추가하므로 소프트웨어를 변경해야 한다고 납득시키는 일은 상당히 힘들것이다.  
이들을 납득시켜서 모뎀 클라이언트를 변경하게 만드는 것은 OCP를 꺨 뿐더러, 짜증나는 일이기도 하다.  
그리고 고객놈은 모뎀 클라이언트 변경은 안된다고 이미 말한바 있다.  

#### 임시방편으로 이 문제를 고칠 수 있다.  
DedicatedModem에서 dial과 jangup 메소드의 연결 상태를 흉내내면 될지도 모른다.  
dial이 호출되지 않았거나 hangup이 호출된 후라면 글자를 보내지 않으면 된다.  
만약 이렇게 변경한다면, 모든 모뎀 클라이언트는 코드를 변경할 필요가 없어지므로 아주 좋아할 것이다.  
**이제 DedUsers에게 그들도 dial과 hangup을 호출해야 한다는 사실을 납득시키기만 하면 된다.**  
![KakaoTalk_20240728_143350107](https://github.com/user-attachments/assets/416f8491-510f-4a6a-9440-954cca7a67ff)  
DedUser를 만드는 사람들이 굉장히 싫어하는 모습을 떠올릴 수 있을 것이다.  
이사람들은 DedicatedModem을 잘 쓰고 있는데, **왜 dial과 hangup을 호출해야 하는가?**  
하지만 이들은 아직 소프트웨어를 작성하기 전이니까, 우리가 원하는 방향으로 하게끔 만드는 일이 모뎀 클라이언트쪽 사람들보다 더 쉽긴 하다.  

#### 얽히고 설킨 의존 관계
몇달 후 DedUser들도 몇백개 생겼을때 고객놈이 다시 와서 새로운 변경사항을 주문한다.  
그동안 이 프로그램들은 국제 전화번호를 다룰 필요는 없었던 것으로 보인다. 그리고 dial의 인자가 char[10]인 이유이기도 하다.  
하지만 이제는 임의 길이의 전화번호를 다이얼할 수 있기를 바란다.  
모든 모뎀 클라이언트를 다 바꾸어야 한다는 점은 분명하다. 다른 선택의 여지가 없기에 고객놈은 이것을 승인했다.  
**하지만 불행하게도, 우리는 DedUser를 작성한 사람들한테도 가서 당신들도 코드를 변경해야 한다고 말해주어야 한다!**  
이들은 우리가 그렇게 해야만 한다고 해서 dial호출을 하도록 하였는데, 이제는 우리가 하라는 대로 했기에 비용이 많이 드는 유지보수 작업을 해야만 한다.  
이러한 경우는 시스템 한 부분에서 사용한 임시방편이 결과적으로는 원래 전혀 관련이 없어야하는 시스템의 다른 부분에서 문제를 일으키는 지저분한 의존관계 흐름을 만들게 된다.  

#### 구해주러 온 어댑터
![KakaoTalk_20240728_144727142](https://github.com/user-attachments/assets/5e6f4866-9a9a-4e7f-a561-8d3c8f2239c0)  
위 그림처럼 맨 처음 문제를 해결하기 위해 어댑터를 사용했더라면 이러한 큰 낭패를 피할 수 있었을 것이다.  
이러할 경우 DedicatedModem은 Modem으로부터 상속받지 않는다.  
모뎀 클라이언트들은 DedicatedModemAdapter를 통해 간접적으로 DedicatedModem을 사용한다.  
이 어댑터는 연결상태를 흉내내기 위해 dial과 hangup을 구현하고, send와 receive 호출은 DedicatedModem에 위임한다.  
이러면 이전에 봤던 모든 어려움이 제거된다는 점을 주목하자.  
Modem의 클라이언트들은 자기 예상대로 동작하는 연결을 보게 되고, DedUser들은 dial이나 hangup을 만지작 거리지 않아도 된다.  
전화번호 요구사항이 변경되더라도 DedUser 들은 영향받지 않는다. 즉, 어댑터를 배치함으로서 LSP와 OCP 위반을 모두 고친 것이다.  
임시방편은 그래도 계속 남아 있게 되는데, 어댑터는 여전히 연결 상태를 흉내내고 있는데, 이게 맘에 들지 않을수도 있을 것이다.  
하지만 모든 의존관계 화살표의 방향이 어뎁터에서 **외부로 나가는** 방향임을 주목하자.  
임시방편은 거의 대부분의 사람이 있는지도 모르는 어댑터 안에 갇혀서 시스템으로부터 분리되어 있다.  
어댑터에게 의존하는 유일한 고정된 의존 관계가 있다면, 그것은 아마 어딘가에 있는 팩토리의 구현 뿐일 것이다.  

## 브리지 패턴
이 문제를 풀기 위한 또 다른 방법도 있다.  
Modem 타입을 처음 생각해냈을 때 이 타입은 단지 여러 하드웨어 장치들의 집합에 대한 인터페이스일 뿐이었다.  
따라서 기반인 Modem 클래스에서 파생하는 HayesModem, USRModem,. ErniesModem 이 있는 것이다.  
하지만 이제 Modem 계층 구조를 나누는 또 다른 방법이 생겼다. 이제 Modem으로부터 파생된 DialModem과 DedicatedModem을 만들 수 있다.  
![KakaoTalk_20240728_151018538](https://github.com/user-attachments/assets/5e93f45c-7525-4ce4-8ae8-d0d43e8f283d)  
위 그림처럼 독립적인 계층 구조를 하나로 합칠 수 있다.  
타입 계층 구조의 말단 노드마다 다이얼인지 전용인지를 자신이 제어하는 하드웨어 앞에 붙인다.  
DedicatedHayesModem 객체는 전용 모뎀의 맥락에서 Hayes 모뎀을 제어한다.  
이것이 이상적인 구조는 아닌데, 새로운 종류의 하드웨어를 추가할 때마다 전용 모뎀일 경우와 다이얼 모뎀일 경우, 이렇게 클래스를 2개씩 만들어야 한다.  
만약 새로운 연결 타입를 추가하기라도 하면 하드웨어마다 클래스를 3개씩 만들어야 한다.  
이 두가지 자유도가 모두 쉽게 바뀌는 성질의 것이라면, 엄청난 수의 파생클래스가 생기게 될 것이다.  
이렇게 계층 구조의 자유도가 하나 이상인 상황이라면 브리지 패턴이 종종 도움이 된다.  
계층 구조를 합치는 대신 각각을 분리해놓고 브리지를 통해 서로를 하나로 연결할 수 있다.  
![KakaoTalk_20240728_152051430](https://github.com/user-attachments/assets/80f51e30-230e-49dd-93cd-ccaf0441cb05)
위 그림에서 브리지 패턴을 쓴 구조를 볼 수 있다.  
모뎀 계층 구조를 두 계층 구조로 쪼개서, 하나는 연결 방법을 나타내게 만들고 하나는 하드웨어를 나타내게 만들었다.  
Modem 사용자는 그대로 Modem 인터페이스를 사용하고 ModemConnectionController가 Modem 인터페이스를 구현한다.  
ModemConnectionController의 파생형들이 연결 메커니즘을 제어한다. DialModemController는 dial과 hangup 메소드 호출을  
ModemConnectionController 기반 클래스의 dialImp와 hangImp에게 전달하기만 할 뿐이다.  
그러면 이 메소드들은 적절한 하드웨어 제어기가 구현하고 있는 ModemImplementation 클래스에게 실제 작업을 위임한다.  
DedModemController의 dial과 hangup 구현은 연결 상태를 흉내 내기만 한다.  
그리고 DedModemController의 send와 receive는 sendImp와 receiveImp에게 위임하는데,  
이것들은 아까와 마찬가지로 ModemImplementation 계층 구조 아래 있는 적절한 구현에게 실제 작업을 위임한다.
ModemConnectionController의 impp 함수 4개의 접근성이 protected라는 것에 주목하자.  
오직 ModemConnectionController의 파생형들만 이 함수들을 사용하기 때문이다. 다른 누구도 이 함수들을 호출하면 안 된다.  
이 구조는 모뎀 사용자에게 아무 영향을 주지 않으면서도 만들 수 있는 구조이지만, 그럼에도 연결에 대한 정책과 하드웨어 구현의 완벽한 분리를 가능하게 한다.  
ModemConnectionController의 파생형들마다 연결에 대한 새로운 정책을 나타내고, 정책들은 자신의 정책을 구현하기 위해 sendImp, receiveImp, dialImp, hangImp를 사용할 수 있다.  
그리고 사용자에게 영향을 주지 않고 새로운 imp 함수들을 만들 수도 있다. 

## 결론
Modem 시나리오의 진정한 문제점은 초기 설계자들이 설계를 잘못했기 떄문이란 말을 하고 싶을 수도 있겠지만, 그건 말도 안되는 소리다.  
이 세상에 충분한 분석 같은 것은 없다. 완벽한 구조를 생각하기 위해 많은 시간을 쏟아붓는 것과 별개로,  
고객이 언제나 그 구조를 망쳐버릴 새로운 변경사항을 들고온다는 사실을 곧 알게 될 것이다. 이것을 벗어날 수 있는 방법은 없다. 
오직 지금 드는 비용과 얻을 수 있는 이점 사이의 균형을 잘 잡는 구조들만 있을 뿐이다.  
시간이 흐르면서 시스템에 대한 요구사항이 변경되면 이 구조들도 변경되어야 하고, 이런 변경들을 잘 해나갈 수 있는 비결은 시스템을 되도록 단순하고 유연하게 유지하는 것이다.  
어댑터 해결 방법은 단순하고 정확하고, 모든 의존관계가 계속 올바른 방향을 가리키게 만들고 구현하기도 매우 쉽다.  
브리지 해결방법은 상당히 복잡하고, 연결과 통신 정책을 분리할 필요와 새로운 연결 정책을 추가할 필요가 있다는 강한 확신이 없다면 굳이 권하지 않는다.  
언제나와 마찬가지로, 어떤 패턴을 사용할 때 이점만 생기는 것이 아니라 비용도 따라온다는 사실을 기억하자.  
지금 문제에 가장 잘 맞는 패턴을 사용해야 한다. 








